[{"content":"Variable Biến là một khái niệm rất quan trọng trong nhiều ngôn ngữ lập trình, được sử dụng để lưu trữ cá giá trị. Chúng ta có thể gán một giá trị cho một biến, khi nào cần giá trị (số, chuỗi, etc) thì gọi tên biến thay vì giá trị, các interpreter, compiler truy xuất đến giá trị đã được gán vào biến khi thực hiện việc tính toán thay cho chúng ta. Con người dễ tiếp thu ngôn ngữ hơn là những giá trị, con số, biến là một ánh xạ đơn giản, từ một từ sinh ra giá trị. Tên của biến phải là độc nhất theo những quy tắc đặt tên của các ngôn ngữ lập trình, một biến chỉ lưu trữ một giá trị tại 1 thời điểm nhất định.\nThoát khỏi việc ghi nhớ các giá trị bằng cách sử dụng biến, các lập trình viên lại có thêm vài vấn đề như sau: Đặt tên biến như thế nào để ngắn gọn, dễ nhớ? Muốn nhiều biến có cùng tên được không? etc. Nhằm giải quyết vấn đề về cách đặt tên biến, các ngôn ngữ lập trình đã hỗ trợ thêm những khái niệm lexical, scope,\u0026hellip;\nVariable naming Nói về việc đặt tên biến thì có nhiều quy tắc\n Tối thiểu:  Tên của một biến phải độc nhất trong một phạm vi nhất định Bao gồm các ký tự trong bảng chữ cái (cả thường và hoa), số, ký tự đặc biệt cho phép tuỳ theo mỗi ngôn ngữ lập trình (JS thì chỉ cho phép 2 ký tự là \u0026ldquo;_\u0026rdquo; và \u0026ldquo;$\u0026quot;) Không được trùng với các reserved word (keyword) Không được bắt đầu bằng số   Nên có:  Ít mang động từ Ngắn ngọn, súc tích, có nghĩa Sử dụng cách nối (như kebab case, snake case, camel case,etc.) khi có nhiều hơn 2 từ \u0026hellip; Và quan trọng hơn hết là phải tuân thủ cú pháp để khai báo biến của ngôn ngữ lập trình!    // ở trong javascript, chúng ta có 3 cách khai báo biến // bằng viêc sử dụng 3 reserved word như var, let, const var revenues; let costs; const profits; Vốn từ vựng nhiều là một lợi thế khi đặt tên biến, tuy nhiên chúng ta không đặt tên biến khác nhau hoàn toàn. Nếu đặt tên biến khác nhau hoàn toàn thì sẽ có rất nhiều biến, việc nhớ chúng sẽ rất tốn thời gian. Thay vì đó, các ngôn ngữ lập trình hỗ trợ các khái niệm idetifier, scope, lexical,etc. để giúp chúng ta tiết kiệm thời gian, công sức.\nIdentifier \u0026amp; access scope Biến là một identifier, tức là định danh (identifier còn có thể các function, class,etc). Chúng ta có thể khởi tạo (tạo ra) nhiều biến có cùng tên, lưu trữ các giá trị khác nhau ở các scope khác nhau. Trình duyệt sẽ dựa vào các scope, xác định các identifier và giá trị của chúng phù hợp. Các identifier khi được khởi tạo luôn được gắn chặt với scope nơi mà chúng được khởi tạo. Chúng ta chỉ có thể truy cập tới các identifier ở các outer scope, không đối với inner scope. Scope có phạm vi truy cập lớn nhất Global Scope. Sự khác biệt giữa let \u0026amp; var\nlet revenues = 100000; let costs = 12345 if (revenue \u0026gt; 0 ){ let profits = revenues - costs } console.log(profits) // ReferenceError: profits is not defined // Hàm console ở global scope truy cập tới biến profits, // tuy nhiên biến profits được khởi tạo ở scope của if (inner scope), // nên việc truy cập thất bại. Tuy nhiên việc truy cập // revenues \u0026amp; costs đều thành công khi ở trong scope của if vì // đối vời scope của if thì global là outer scope Khi thực hiện việc tìm kiếm các identifier thì ta sẽ tuân theo quy tắc từ trong ra ngoài. Javascript sẽ xét ở scope hiện tại, sau đó chuyện tới outer scope, xét tiếp, tiếp tục chuyển tới outer scope,\u0026hellip; cho tới khi gặp được identifier hợp lệ hoặc tới global scope mà không tìm được thì sẽ báo lỗi - scopes chain. Đối với từ khoá let thì quy tắc scopes chain đúng hoàn toàn, và nhiều ngôn ngữ khác cũng vậy. Tuy nhiên điều này không đúng với var.\nif (true){ var z = 100 } console.log(z) // 100 // Điều này chứng mình rằng khi khai báo var, quy tắc scope chain // không còn chính xác nữa var đặc biệt hơn với let ở chỗ nó không tuân theo quy tắc chung. Chúng ta có thể kết luận rằng, khi khai báo identifier với từ khoá var sẽ có scope là global không? Tất nhiên là không!\nfunction initialVariable() { var z = \u0026#39;this is z\u0026#39; console.log(z) } initialVariable() console.log(z) // this is z // ReferenceError: z is not defined Vậy nên ta không thể kết luận rằng khai báo identifier với từ khoá var sẽ có scope là global. Vậy thì lí do tại sao ví dụ ở trên lại bị sai nhỉ? Câu trả lời là đối với scope của hàm thì có một chút khác biệt, có tên là lexical. Khi khai báo identifier bằng var, thay vì bind vào scope, thì identifier được bind vào lexical. Ngoại trừ điều đó ra thì var còn có khả năng redeclarion (tái khai báo) mà không gặp lỗi. (làm với let thì sẽ gặp lỗi SyntaxError: Identifier _ has already been declared)\nvar z =\u0026#39;this is z at first\u0026#39; console.log(z) function initialVariable() { var z = \u0026#39;this is z\u0026#39; console.log(z) var z = \u0026#39;this is z but 4th\u0026#39; // redeclaration  console.log(z) } initialVariable() console.log(z) // this is z at first // this is z // this is z but 4th // this is z at first Xét thêm trường hợp này\nvar z= 1000 function f() { var fs = [] for (var i = 0; i \u0026lt; 5; i++) { fs.push(function () { var z = i console.log(z) }) } fs[3]() } f() console.log(z) // 5 // i được khai báo ở lexical f, khi thực hiện vòng lặp với post operator là i++ thì // đang thay đổi giá trị của biến i ở lexical f. Ngoại trừ việc bind khác một chút var vẫn tuân theo quy tắc của scope chain. Có nhiều bạn tưởng rằng var sẽ tạo một property ở global object (cụ thể window ) - chưa hoàn toàn đúng, chỉ khi nào bạn khai báo bằng var ở global scope thì mới tạo property, còn lại thì không.\nfunction f() { var z = \u0026#39;111\u0026#39; console.log(z) console.log(window.z) } f() const Điều khiến identifier đặc biệt là không cho phép direct assignment. Assignment là một toán tử cho phép cập nhật giá trị đã được lưu trữ của identifier.\nconst z = 100; z = \u0026#39;??\u0026#39; // TypeError: Assignment to constant variable. Tuy nhiên ,việc thay đổi nội tại bên trong, hoặc thay đổi thông qua trung gian vẫn có thể.(Đối với references data type)\nconst z = [] console.log(z) z.push(1,2,3,4) console.log(z) // [] // (4) [1, 2, 3, 4] const z = {} z.name = \u0026#39;z\u0026#39; console.log(z) // {name: \u0026#34;z\u0026#34;} Hoisting \u0026amp; Tempotary Dead Zone  Một identifier được khỏi tạo thông qua 1 hoặc 2 giai đoạn : declaration (defination) và initialization. Giai đoạn 2 có thể có hoặc không. declaration mang ý nghĩa cấp vùng nhớ dùng để lưu giá trị và bind identifier, initialization mang ý nghĩa khởi tạo cho giá trị ban đầu là bao nhiêu. Nếu không có initialization thì giá trị mạc định là undefined  let z; // declaration let z = 100; // declaration + initialization Hãy xem xét các ví dụ sau:\nconsole.log(z) let z = 10; // ReferenceError: Cannot access \u0026#39;z\u0026#39; before initialization // Chúng ta đã sử dụng biến z trước khi nó được khai báo, đây được gọi là tdz console.log(z) var z = 10; // undefined // Nếu thay let bằng var thì ta lại nhận được giá trị. Đây là ví dụ cho việc hoisting Tempotary Dead Zone là khái niệm dùng để nói về việc sử dụng một identifier trước khi được tạo ra.Hoisting áp dụng đối với identifier được khai báo bằng từ khoá var và function. Hoisting chỉ hiệu quả trong một lexical. Hoisting nghĩa là Javascript sẽ đem tất cả các biến phù hợp ( khai báo bằng var và function), thực hiện việc declaration trước, khi đến dòng thực sự khai báo, chỉ phải thực hiện assignment mà thôi.\nTDZ không phải ám chỉ thứ tự khai báo các biến và sử dụng, mà thường dùng để nói về thứ tự thực thi (Execution Order). Miễn là tại thời điểm thực thi các biến đã được khởi là là ổn. TDZ thường hay đề cập đối với let hơn là var (var sẽ Javascript áp dụng hoisting nên chuyện chưa được khởi tạo không xảy ra - chỉ có vấn đề là giá trị là undefined mà thôi). Để khắc phục tình trạng một biến gặp trường hợp tdz thì nên cân nhắc đem tất cả các biến lên khai báo ở đầu scope/lexical\nif(true){ console.log(z); console.log(x); var z = \u0026#39;this is z\u0026#39;; let x = \u0026#39;this is x\u0026#39;; } // undefined // ReferenceError: Cannot access \u0026#39;x\u0026#39; before initialization // Đây là ví dụ về thực thi if (true){ //  function f(){ console.log(z) } let z = \u0026#39;this is z\u0026#39; } f() // // this is z // this is z - khi khai hàm bằng function =\u0026gt; giống như var // bind thẳng lexical chứ không phải scope - arrow function // khắc phục được điểm này Khi bạn sử dụng các từ khoá để khởi tạo các identifier, thì các identifier được bind vào scope/lexical tuỳ thuộc vào nơi khai báo. Nhưng nếu bạn không khai báo biến mà trực tiếp assignment thì mặc định Javascript sẽ làm tự động tạo cho bạn 1 biến ở global scope (Nếu chưa tồn tại ở scope chain dẫn ra global scope)\nx = \u0026#39;this is x\u0026#39;; function f() { function g(){ z = \u0026#39;this is z lexical of g\u0026#39; } g() } f(); console.log(globalThis) console.log(x, z); // this is x this is z lexical of g  References \u0026amp; more resources  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference   P/S: Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!\n","date":"2021-04-12T19:01:17+07:00","image":"https://sonlhcsuit.github.io/p/variable/cover_hu827c0ed010dfc5634e95366bcb9fa524_10906_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/variable/","title":"Variable"},{"content":"Khi xử lý với Event thông qua DOM ở trong Javascript, cần phải hiểu một chút kỹ càng về cách các event hoạt động. Mỗi khi một event được trigger, bắt đầu thực thi listener thì cùng lúc cũng có nhiều listener được kích hoạt cùng lúc. Có các cơ chế để trình duyệt thực hiện những listener theo một thứ tự xác định. Các cơ chế cơ bản đó là bubble \u0026amp; capturing.\nXem xét các ví dụ sau đây về độ sâu (depth) của cây DOM thông qua đoạn HTML\n\u0026lt;div class=\u0026#34;box box-1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box box-2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box box-3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; *{ margin: 0; padding: 0; box-sizing: border-box; } .box { display: block; margin:20px; } .box.box-1{ width: 40vh; height: 40vh; border: solid 1px red; } .box.box-2{ width: 30vh; height: 30vh; border: solid 1px black; } .box.box-3{ width: 20vh; height: 20vh; border: solid 1px blue; } Khi hiển thị trên trình duyệt thì kết quả sẽ gồm 3 hình vuông lớn nhỏ theo kích thước và thứ tự sau:  Hiển thị đoạn của code ở phía trên \nBox 3 - nằm trong Box 2 - nằm trong Box 1. Sử dụng một chút logic thì ta cũng có thể nhận thấy rằng khi người dùng click vào Box 3 thì cũng là người dùng click vào Box 2 và Box 1 (bởi vì Box 2 và Box 1 có kích thước lớn hơn và Box 3 nằm ở bên trong)\nNếu chúng ta thêm các listener vào event click, thì khi event được trigger ở Box 3 thì các listener ở Box 2, Box 1 cũng được trigger theo. Và kết quả là cả 3 listener đều được thực thi. Điều này đúng với logic căn bản, tuy nhiên nếu các listener này xung đột lẫn nhau (ví dụ ẩn/hiện các component thì không hợp lý chút nào ). Cần nắm rõ cơ chế lan truyền - propagation - các event.\nCó 2 cơ chế lan truyền chính của các trình duyệt hiện tại là bubble \u0026amp; capture. Nhiều trình duyệt đã chuyển sang cơ chế mặc định là bubbles - từ \u0026ldquo;dưới lên \u0026ldquo;trên\u0026rdquo;. Còn cơ chế capture sẽ ngược lại, từ \u0026ldquo;trên\u0026rdquo; xuống \u0026ldquo;dưới\u0026rdquo;.\nĐối với cơ chế capture: trình duyệt sẽ bắt đầu từ gốc của cây DOM, tìm dần xuống tới element được kích hoạt (Box 3). Để tới được Box 3 thì phải trải qua các Node sau : html -\u0026gt; body -\u0026gt; box 1 -\u0026gt; box 2 -\u0026gt; box 3. Như vậy theo cách duyệt cây này thì các listener sẽ được trigger theo thứ tự trên (nếu đã được định nghĩa). Còn cơ chế bubble sẽ thực hiện ngược lại, từ node lá duyệt ngược lên gốc: box 3 -\u0026gt; box 2 -\u0026gt; box 1 -\u0026gt; body -\u0026gt; html. Và các listener sẽ được kích hoạt với thứ tự trên.\nMặc định các trình duyệt hiện đại đều sử dụng cơ chế bubble. Tuy nhiên ta có thể chỉ định sử dụng cơ chết capture bằng cách sau.\ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function (){ console.log(this.classList.value) }) }) // bubbles  Cơ chế bubble \ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function() { console.log(this.classList.value) }, { capture: true }) }) // capture  Cơ chế capture \nTuy nhiên đôi khi chúng ta cần ngăn chặn sự lan truyền (tức là chỉ kích hoạt những listener phía trước để đảm bảo đúng dữ kiện ) bằng cách sử dụng phương thức Event.stopPropagation()\ndocument.querySelectorAll(\u0026#39;.box\u0026#39;).forEach(element =\u0026gt; { element.addEventListener(\u0026#34;click\u0026#34;, function(event) { console.log(this.classList.value) event.stopPropagation() }, { // capture:true  } ) })  Cơ chế bubble với stopPropagation   Cơ chế capture với stopPropagation \nWednesday 31/03/2021\n","date":"2021-03-31T11:14:24+07:00","image":"https://sonlhcsuit.github.io/p/event-bubbles/cover_hud38f19311a47fb7e81e0a14471226114_599984_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/event-bubbles/","title":"Event Bubbling \u0026 Capturing"},{"content":"Hôm nay cũng như bao hôm khác, sẽ là một ngày chủ nhật thật đẹp với bầu trời xanh của thành phố quen thuộc.\nMới vừa bước ra công ty sau một ngày chủ nhật mệt mỏi, lái trên đường về dọc kênh Nhiêu Lộc - Thị Nghè. Đang trên đường mà cứ thả hồn vào trời mây, việc lái xe thì nhường lại cho tay chân với phản xạ cơ bản.\nKhông hiểu vì lí do gì mà cảm xúc trống rỗng, buồn,\u0026hellip; lấp đầy tâm trí. Không biết buồn vì điều chi, chỉ cảm thấy thiếu 1 thứ gì đó rất quan trọng.\nCàng lớn, cảm xúc tích cực càng ít đi, thay vào đó là những khoảng lặng.\nSực nhớ ra hôm nay là valentine trắng, dường như chính cảm xúc mình lại chết một ít.\nSunday 14/03/21\n","date":"2021-03-15T01:17:31+07:00","image":"https://sonlhcsuit.github.io/p/valentine-trang/cover_hu7a3348dd1f670f38516753d703135e0a_1056819_120x120_fill_box_smart1_2.png","permalink":"https://sonlhcsuit.github.io/p/valentine-trang/","title":"Valentine Trang"}]