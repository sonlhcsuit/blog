<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sơn Lưu Blog</title><link>https://sonlhcsuit.github.io/</link><description>Recent content on Sơn Lưu Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 18 Apr 2021 00:17:35 +0700</lastBuildDate><atom:link href="https://sonlhcsuit.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Functions</title><link>https://sonlhcsuit.github.io/p/function/</link><pubDate>Sun, 18 Apr 2021 00:17:35 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/function/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/function/cover.png" alt="Featured image of post Functions" />&lt;h1 id="function">Function&lt;/h1>
&lt;p>&lt;strong>Function&lt;/strong> là một khái niệm quan trọng trong nhiều ngôn ngữ lập trình bậc cao. Theo định nghĩa từ toán học thì &lt;strong>function&lt;/strong> là những &lt;strong>expression, rules,laws&lt;/strong> được sử dụng để định nghĩa những &lt;strong>relation&lt;/strong> giữa nhiều &lt;strong>dependant variables&lt;/strong> (biến độc lập). Nói một cách khó hiểu hơn, là một &lt;strong>mapping&lt;/strong> (ánh xạ) từ một giá trị ở &lt;em>miền giá trị&lt;/em> này sang một giá trị khác ở &lt;em>miền giá trị&lt;/em> khác.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 208; flex-basis: 500px">
&lt;a href="https://sonlhcsuit.github.io/p/function/function-algebra.png" data-size="828x397">&lt;img src="https://sonlhcsuit.github.io/p/function/function-algebra.png"
srcset="https://sonlhcsuit.github.io/p/function/function-algebra_hu311918eba7412b1275f9d8949c4bb2a8_8626_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/function/function-algebra_hu311918eba7412b1275f9d8949c4bb2a8_8626_1024x0_resize_box_2.png 1024w"
width="828"
height="397"
loading="lazy"
alt="Định nghĩa về function theo toán học">
&lt;/a>
&lt;figcaption>Định nghĩa về function theo toán học&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Khi làm việc với các ngôn ngữ lập trình thì chúng ta lại sử dụng hàm khác đi một chút. &lt;strong>Function&lt;/strong> là một &amp;ldquo;cỗ máy&amp;rdquo; nhận vào những &lt;strong>input&lt;/strong> và đưa ra cho chúng ta &lt;strong>output&lt;/strong>. Khi viết một hàm, chúng ta đang thiết kế cách mà &amp;ldquo;cỗ máy&amp;rdquo; hoạt động, cách chuyển đổi từ &lt;strong>input&lt;/strong> sang &lt;strong>output&lt;/strong>, chúng ta có thể sử dụng bản thiết kế này chúng ở mọi nơi bằng cách &lt;strong>invoke,call&lt;/strong> (gọi hàm - sẽ có sự khác biệt phía bên dưới).&lt;/p>
&lt;p>&lt;figure style="flex-grow: 82; flex-basis: 199px">
&lt;a href="https://sonlhcsuit.github.io/p/function/function-machine.png" data-size="500x603">&lt;img src="https://sonlhcsuit.github.io/p/function/function-machine.png"
srcset="https://sonlhcsuit.github.io/p/function/function-machine_huc25f250195a519fdfdea4f9a43f2fd11_14605_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/function/function-machine_huc25f250195a519fdfdea4f9a43f2fd11_14605_1024x0_resize_box_2.png 1024w"
width="500"
height="603"
loading="lazy"
alt="Định nghĩa về function nhưng bớt khó hiểu hơn">
&lt;/a>
&lt;figcaption>Định nghĩa về function nhưng bớt khó hiểu hơn&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h1 id="create-function">Create function&lt;/h1>
&lt;p>Có một vài điều cần lưu ý khi sử dụng &lt;strong>function&lt;/strong> như sau:
- Phải khai báo &lt;strong>function&lt;/strong> trước khi sử dụng
- &lt;strong>function&lt;/strong> không chạy tại thời điểm được khai báo mà chỉ chạy khi được invoke/call
Ngoại trừ những điều trên thì còn một vài thứ linh tinh nữa. Trong Javascript thì chúng ta có thể khai báo &lt;strong>function&lt;/strong> bằng 2 cách - sử dụng &lt;strong>function definition&lt;/strong> hoặc &lt;strong>function expression&lt;/strong>. Javascript xem &lt;strong>function&lt;/strong> như là một đối tượng, nên &lt;strong>function&lt;/strong> có thể là &lt;strong>output&lt;/strong> của một function khác.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng function definition với từ khoá function
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">functionName&lt;/span>(&lt;span style="color:#a6e22e">parameters_comes_here&lt;/span>){
&lt;span style="color:#75715e">// function_body here
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// remember to return something
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#75715e">// Sử dụng function expression
&lt;/span>&lt;span style="color:#75715e">// const / let/ var đều có thể
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">myFunctionName&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">parameters_comes_here&lt;/span>)=&amp;gt;{
&lt;span style="color:#75715e">// function_body here
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// remember to return something
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="parameter--argument">Parameter / Argument&lt;/h1>
&lt;p>Khi khai báo hàm thì ta cần phải chú ý &lt;strong>function name&lt;/strong> (quy tắc đặt tên giống tên biến) và &lt;strong>function parameter&lt;/strong>. &lt;strong>Parameter&lt;/strong> nghĩa là tham số đầu vào - một cách gọi khác của &lt;strong>input&lt;/strong>. &lt;strong>Parameter&lt;/strong> là biến dùng để lưu giá trị nhận được khi &lt;strong>function&lt;/strong> được invoke/call. &lt;strong>Function&lt;/strong> sẽ yêu cầu một số lượng nhất định các &lt;strong>parameter&lt;/strong> khi khai báo, đồng thời cũng phải đúng số lượng các &lt;strong>argument&lt;/strong> truyền vào khi hàm được &lt;strong>invoke/call&lt;/strong> và đúng thứ tự được khai báo . Tuy nhiên Javascript không bắt buộc điều này, số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> có thể khác nhau. Điều này dẫn tới một số vấn nhỏ.&lt;br>
Đối với việc số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> bằng nhau.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Khai báo hàm cube với 3 parameter là a, b, c
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
}
&lt;span style="color:#75715e">// Invoke/call hàm cube với 3 argument tương ứng là 2, 3, 4
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// 99
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Đối với việc số lượng các &lt;strong>parameter&lt;/strong> và &lt;strong>argument&lt;/strong> không bằng nhau.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Khai báo hàm cube với 3 parameter là a, b, c
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>&lt;span style="color:#f92672">**&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
}
&lt;span style="color:#75715e">// Invoke/call hàm cube với 2 argument tương ứng là 2, 3
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// NaN
&lt;/span>&lt;span style="color:#75715e">// Lý do bởi vì giá trị của c không được truyền vào =&amp;gt; các biến
&lt;/span>&lt;span style="color:#75715e">// có giá trị mặc định là undefined nếu không có quá trình initialization
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// Invoke/call hàm cube với 5 argument tương ứng là 2, 3, 4, 5, 6
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;span style="color:#75715e">// 99
&lt;/span>&lt;span style="color:#75715e">// Thiếu mất giá trị 5, 6. Như vậy liệu rằng hàm
&lt;/span>&lt;span style="color:#75715e">// của chúng có đang ở dạng tổng quát (general)?
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thông qua 2 ví dụ trên về sự khác biệt số lượng &lt;strong>parameter/argument&lt;/strong>, ta có thể có vài rắc rối cần phải giải quyết. Một trong cách giải quyết đơn giản nhất là sử dụng duy nhất 1 &lt;strong>parameter&lt;/strong> với kiểu dữ liệu là &lt;strong>array&lt;/strong>. Ngoại trừ cách đó thì chúng ta còn có thể sử dụng &lt;strong>reserved word&lt;/strong> là &lt;strong>arguments&lt;/strong> - giúp chúng ta biến tất cả các &lt;strong>arguments&lt;/strong> thành đối tượng array-like (gần như mảng nhưng không phải mảng).&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng mảng
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> ){
&lt;span style="color:#a6e22e">sum&lt;/span>&lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">arrayOfNumbers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span>
}
&lt;span style="color:#75715e">// sử dụng hàm
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>([&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>])
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#75715e">// Sử dụng từ khoá arguments. Khi sử dụng từ khoá thì chúng
&lt;/span>&lt;span style="color:#75715e">// ta có thể không khai báo parameter. Nếu khai báo thì cũng
&lt;/span>&lt;span style="color:#75715e">// vẫn có thể sử dụng như một biến
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>,&lt;span style="color:#a6e22e">b&lt;/span>,&lt;span style="color:#a6e22e">c&lt;/span>){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">arguments&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;span style="color:#75715e">// tuy nhiên chúng ta vẫn có thể truy cập tới arguments[0]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// arguments[1], arguments[2] bằng a, b, c theo thứ tự
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">sum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> ; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> ){
&lt;span style="color:#a6e22e">sum&lt;/span>&lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">arguments&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cube&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>,&lt;span style="color:#ae81ff">7&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">9&lt;/span>,&lt;span style="color:#ae81ff">10&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="lexical-environment--execution-context--execution-stack">Lexical Environment / Execution Context / Execution Stack&lt;/h1>
&lt;p>Khi khai báo &lt;strong>function&lt;/strong> ta sử dụng cú pháp &lt;strong>{}&lt;/strong> để tạo &lt;strong>scope&lt;/strong> dánh cho &lt;strong>function body&lt;/strong>. &lt;strong>Scope&lt;/strong> này còn có tên là &lt;strong>Lexical Environment&lt;/strong> (&lt;strong>Lexical&lt;/strong>).Khi khai báo identifiers thi identifier sẽ bind với lexical/scope đó (mặc định). &lt;strong>Lexical&lt;/strong> thường chứa thông tin về về các &lt;strong>identifier&lt;/strong> , đồng thời cũng chứa thông tin về &lt;strong>parent lexical&lt;/strong> khi tìm kiếm &lt;strong>identifier&lt;/strong> không tồn tại trong &lt;strong>lexical&lt;/strong> hiện tại. Khi một hàm được &lt;strong>invoke/call&lt;/strong> thì ngay lập tức Javascrit engine tạo ra một &lt;strong>execution context&lt;/strong> và một &lt;strong>lexical&lt;/strong> cho việc lưu trữ các biến (giả sử nếu cùng tên trong hàm). &lt;strong>Execution context&lt;/strong> đặt chúng lên đầu của &lt;strong>execution stack&lt;/strong>, đồng thời lưu vào &lt;strong>lexical&lt;/strong> vị trí của &lt;strong>statement pointer&lt;/strong> hiện tại, đồng thời cập nhật giá trị &lt;strong>statement pointer&lt;/strong> thành nơi bắt đầu hàm vừa được &lt;strong>invoke/call&lt;/strong>. &lt;strong>Execution context&lt;/strong> lớn nhất là &lt;strong>global&lt;/strong>.&lt;/p>
&lt;p>Javascript engine sẽ thực hiện lần lượt từ trên xuống dưới (top to bottom of stack). Khi &lt;strong>function&lt;/strong> hoàn thành, &lt;strong>execution context&lt;/strong> của &lt;strong>function&lt;/strong> đó sẽ được &lt;strong>pop&lt;/strong> ra khỏi &lt;strong>execution context&lt;/strong>,và &lt;strong>statement pointer&lt;/strong> sẽ quay về vị trí đã gọi &lt;strong>function&lt;/strong> vừa hoàn thành, tiếp tục công việc thực thi từng dùng. &lt;strong>Execution stack&lt;/strong> đảm bảo được rằng các được gọi sau (trong các hàm bất kỳ) hoàn thành trước để đảm bảo tính đúng đắn của chương trình.&lt;/p>
&lt;p>Quy tắc tìm kiếm các &lt;strong>identifier&lt;/strong> dọc theo mối quan hệ cha - con của &lt;strong>lexical&lt;/strong> được gọi là &lt;strong>scope chain&lt;/strong>
&lt;strong>function&lt;/strong>&lt;/p>
&lt;h1 id="hoisting">Hoisting&lt;/h1>
&lt;p>&lt;strong>Hoisting&lt;/strong> (Xem thêm ở &lt;a class="link" href="https://sonlhcsuit.github.io/p/variable" >Variable&lt;/a>), tuy nhiên có một điều bổ sung nữa là. Giai đoạn &lt;strong>hoisting&lt;/strong> chỉ xảy ra khi một &lt;strong>execution context&lt;/strong> được tạo ra, và việc khai báo đè cũng chỉ ảnh hưởng trong &lt;strong>execution context&lt;/strong> đó.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">22&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(){
&lt;span style="color:#75715e">// Hoisting function =&amp;gt; bị ghi đè
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#75715e">// let h = 10
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;span style="color:#75715e">// debugger;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From h w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">h&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From g w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#a6e22e">g&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From f w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Một vài sự chú ý nhỏ đây là trong &lt;strong>lexical&lt;/strong> của hàm &lt;strong>f&lt;/strong> thì &lt;strong>identifier&lt;/strong> &lt;strong>h&lt;/strong> đã được khai báo bằng từ khoá &lt;code>let&lt;/code>, vậy tại sao khi in &lt;strong>h&lt;/strong> ra console lại bị thay đổi? Khi sử dụng từ khoá &lt;strong>function&lt;/strong> thì &lt;strong>hoisting&lt;/strong> xảy ra, thay thế &lt;strong>identifier&lt;/strong> &lt;strong>h&lt;/strong> của hàm &lt;strong>f&lt;/strong>, thay thế bằng &lt;strong>h&lt;/strong> của hàm &lt;strong>g&lt;/strong>. Vì &lt;strong>lexical&lt;/strong> hiện tại là hàm &lt;strong>g&lt;/strong> Javascript engine sẽ chọn &lt;strong>identifier&lt;/strong> ở gần &lt;strong>lexical&lt;/strong> hiện tại nhất (là &lt;strong>idetitier&lt;/strong> &lt;strong>h&lt;/strong> của hàm &lt;strong>g&lt;/strong> chứ không phải &lt;strong>f&lt;/strong>).&lt;/p>
&lt;p>Ngoài ra thì ở dòng đầu tiên của hàm &lt;strong>h&lt;/strong>, kết quả chúng ta nhận được &lt;strong>undefined&lt;/strong> chứ không phải &lt;strong>12&lt;/strong>. Lí do là các &lt;strong>parameter&lt;/strong> cũng được khai báo bằng từ khoá &lt;strong>var&lt;/strong> giống như biến (tức là cũng xảy ra &lt;strong>hoisting&lt;/strong>). Sau đó mới được gán giá trị được truyền vào lúc được &lt;strong>invoke/call&lt;/strong>. Vậy nên giá trị của &lt;strong>a&lt;/strong> là &lt;strong>undefined&lt;/strong> (vì mới được khởi tạo) và đồng thơi cũng được copy từ &lt;strong>argument&lt;/strong> sang - tuy nhiên hàm h lại gọi với không có &lt;strong>argument&lt;/strong> nào nên các &lt;strong>parameter&lt;/strong> vẫn giữ giá trị là undefined.&lt;/p>
&lt;h1 id="callback--higher-order-function--closure">Callback / Higher Order Function / Closure&lt;/h1>
&lt;p>Trong Javascrip, function được xem là một Object (một kiểu dữ liệu).Điều này đồng nghĩa với ta có thể truyền một function như là argument khi invoke/call một function khác, hay nó cũng có thể là một gì đó được trả về như là kết quả của việc invoke/call một function.&lt;/p>
&lt;p>Những function được truyền như argument khi invoke/call một function khác thì có tên là callback. Những function không thể được truyền như callback thì được gọi là first-class function hay là higher order function.&lt;/p>
&lt;p>Closure là khả năng ghi nhớ, kết hợp &lt;strong>lexical&lt;/strong> giữa các hàm được trả về/ callback / listener. Thay vì tìm kiếm identifier ở global lexical thì function y sẽ tìm kiếm ở lexical mà được khai báo trước (tức là lexical của function x) rồi mới tới &lt;strong>lexical&lt;/strong> hiện tại (nơi mà function được invoke/call)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>(){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;hihihi&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;huhuhu&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">y&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;?&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>()
&lt;span style="color:#a6e22e">y&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;span style="color:#75715e">// hihih
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ngoài ra, có một ví dụ cổ điển việc closure/lexical ở MDN, mình trích dẫn nó ở đây. Hãy tự suy nghĩ xem cách giải quyết và lý giải rằng lại sao nó lại như thế nhé (cần biết về lexical/scope chain/ closure)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">p&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;help&amp;#34;&lt;/span>&amp;gt;Helpful notes will appear here&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;E-mail: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;Name: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;Age: &amp;lt;&lt;span style="color:#f92672">input&lt;/span> &lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">showHelp&lt;/span>(&lt;span style="color:#a6e22e">help&lt;/span>) {
document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">textContent&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">help&lt;/span>;
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">setupHelp&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;email&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your e-mail address&amp;#39;&lt;/span>},
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;name&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your full name&amp;#39;&lt;/span>},
{&lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;age&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;help&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Your age (you must be over 16)&amp;#39;&lt;/span>}
];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">item&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">helpText&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>];
document.&lt;span style="color:#a6e22e">getElementById&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span>).&lt;span style="color:#a6e22e">onfocus&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;span style="color:#a6e22e">showHelp&lt;/span>(&lt;span style="color:#a6e22e">item&lt;/span>.&lt;span style="color:#a6e22e">help&lt;/span>);
}
}
}
&lt;span style="color:#a6e22e">setupHelp&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="call--invoke">Call / Invoke&lt;/h1>
&lt;p>Invoke là việc gọi trực tiếp một hàm bằng việc dùng tên &lt;code>f()&lt;/code>. Call là sử dụng HOF để invoke hàm đó bằng cách gián tiếp&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">callback&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From g w/love&amp;#39;&lt;/span>)
&lt;span style="color:#a6e22e">cb&lt;/span>()
}
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">h&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;From h w/love&amp;#39;&lt;/span>)
}
&lt;span style="color:#a6e22e">g&lt;/span>(&lt;span style="color:#a6e22e">h&lt;/span>)
&lt;span style="color:#75715e">// invoke g, but g call h instead us
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://www.britannica.com/science/function-mathematics">https://www.britannica.com/science/function-mathematics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/50884893/calling-vs-invoking-a-function">https://stackoverflow.com/questions/50884893/calling-vs-invoking-a-function&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.w3schools.com/js/js_function_definition.asp">https://www.w3schools.com/js/js_function_definition.asp&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope">https://stackoverflow.com/questions/12599965/lexical-environment-and-function-scope&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Variable</title><link>https://sonlhcsuit.github.io/p/variable/</link><pubDate>Mon, 12 Apr 2021 19:01:17 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/variable/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/variable/cover.png" alt="Featured image of post Variable" />&lt;h1 id="variable">Variable&lt;/h1>
&lt;p>Biến là một khái niệm rất quan trọng trong nhiều ngôn ngữ lập trình, được sử dụng để lưu trữ cá giá trị. Chúng ta có thể gán một giá trị cho một biến, khi nào cần giá trị (số, chuỗi, etc) thì gọi tên biến thay vì giá trị, các &lt;em>interpreter&lt;/em>, &lt;em>compiler&lt;/em> truy xuất đến giá trị đã được gán vào biến khi thực hiện việc tính toán thay cho chúng ta. Con người dễ tiếp thu ngôn ngữ hơn là những giá trị, con số, biến là một ánh xạ đơn giản, từ &lt;em>một từ&lt;/em> sinh ra &lt;em>giá trị&lt;/em>. Tên của biến phải là độc nhất theo những quy tắc đặt tên của các ngôn ngữ lập trình, một biến chỉ lưu trữ một giá trị tại 1 thời điểm nhất định.&lt;/p>
&lt;p>Thoát khỏi việc ghi nhớ các giá trị bằng cách sử dụng biến, các lập trình viên lại có thêm vài vấn đề như sau: Đặt tên biến như thế nào để ngắn gọn, dễ nhớ? Muốn nhiều biến có cùng tên được không? etc. Nhằm giải quyết vấn đề về &lt;em>cách đặt tên biến&lt;/em>, các ngôn ngữ lập trình đã hỗ trợ thêm những khái niệm &lt;em>lexical, scope,&amp;hellip;&lt;/em>&lt;/p>
&lt;h1 id="variable-naming">Variable naming&lt;/h1>
&lt;p>Nói về việc đặt tên biến thì có nhiều quy tắc&lt;/p>
&lt;ul>
&lt;li>Tối thiểu:
&lt;ul>
&lt;li>Tên của một biến phải độc nhất trong một phạm vi nhất định&lt;/li>
&lt;li>Bao gồm các ký tự trong bảng chữ cái (cả thường và hoa), số, ký tự đặc biệt cho phép tuỳ theo mỗi ngôn ngữ lập trình (JS thì chỉ cho phép 2 ký tự là &amp;ldquo;_&amp;rdquo; và &amp;ldquo;$&amp;quot;)&lt;/li>
&lt;li>Không được trùng với các reserved word (keyword)&lt;/li>
&lt;li>Không được bắt đầu bằng số&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Nên có:
&lt;ul>
&lt;li>Ít mang động từ&lt;/li>
&lt;li>Ngắn ngọn, súc tích, có nghĩa&lt;/li>
&lt;li>Sử dụng cách nối (như kebab case, snake case, camel case,etc.) khi có nhiều hơn 2 từ&lt;/li>
&lt;li>&amp;hellip;
Và quan trọng hơn hết là phải tuân thủ cú pháp để khai báo biến của ngôn ngữ lập trình!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">// ở trong javascript, chúng ta có 3 cách khai báo biến
&lt;/span>&lt;span style="color:#75715e">// bằng viêc sử dụng 3 reserved word như var, let, const
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">profits&lt;/span>;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vốn từ vựng nhiều là một lợi thế khi đặt tên biến, tuy nhiên chúng ta không đặt tên biến khác nhau hoàn toàn. Nếu đặt tên biến khác nhau hoàn toàn thì sẽ có rất nhiều biến, việc nhớ chúng sẽ rất tốn thời gian. Thay vì đó, các ngôn ngữ lập trình hỗ trợ các khái niệm &lt;em>idetifier, scope, lexical,etc.&lt;/em> để giúp chúng ta tiết kiệm thời gian, công sức.&lt;/p>
&lt;h1 id="identifier--access-scope">Identifier &amp;amp; access scope&lt;/h1>
&lt;p>Biến là một &lt;strong>identifier&lt;/strong>, tức là định danh (identifier còn có thể các function, class,etc). Chúng ta có thể khởi tạo (tạo ra) nhiều biến có cùng tên, lưu trữ các giá trị khác nhau ở các &lt;strong>scope&lt;/strong> khác nhau. Trình duyệt sẽ dựa vào các scope, xác định các &lt;strong>identifier&lt;/strong> và giá trị của chúng phù hợp. Các &lt;strong>identifier&lt;/strong> khi được khởi tạo luôn được gắn chặt với &lt;strong>scope&lt;/strong> nơi mà chúng được khởi tạo. Chúng ta chỉ có thể truy cập tới các identifier ở các &lt;strong>outer scope&lt;/strong>, không đối với &lt;strong>inner scope&lt;/strong>. &lt;strong>Scope&lt;/strong> có phạm vi truy cập lớn nhất &lt;strong>Global Scope&lt;/strong>. Sự khác biệt giữa &lt;strong>let&lt;/strong> &amp;amp; &lt;strong>var&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">12345&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">revenue&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ){
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">profits&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">revenues&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">costs&lt;/span>
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">profits&lt;/span>)
&lt;span style="color:#75715e">// ReferenceError: profits is not defined
&lt;/span>&lt;span style="color:#75715e">// Hàm console ở global scope truy cập tới biến profits,
&lt;/span>&lt;span style="color:#75715e">// tuy nhiên biến profits được khởi tạo ở scope của if (inner scope),
&lt;/span>&lt;span style="color:#75715e">// nên việc truy cập thất bại. Tuy nhiên việc truy cập
&lt;/span>&lt;span style="color:#75715e">// revenues &amp;amp; costs đều thành công khi ở trong scope của if vì
&lt;/span>&lt;span style="color:#75715e">// đối vời scope của if thì global là outer scope
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi thực hiện việc tìm kiếm các &lt;strong>identifier&lt;/strong> thì ta sẽ tuân theo quy tắc từ trong ra ngoài. Javascript sẽ xét ở scope hiện tại, sau đó chuyện tới outer scope, xét tiếp, tiếp tục chuyển tới outer scope,&amp;hellip; cho tới khi gặp được &lt;strong>identifier&lt;/strong> hợp lệ hoặc tới global scope mà không tìm được thì sẽ báo lỗi - scopes chain. Đối với từ khoá &lt;code>let&lt;/code> thì quy tắc &lt;strong>scopes chain&lt;/strong> đúng hoàn toàn, và nhiều ngôn ngữ khác cũng vậy. Tuy nhiên điều này không đúng với &lt;code>var&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// 100
&lt;/span>&lt;span style="color:#75715e">// Điều này chứng mình rằng khi khai báo var, quy tắc scope chain
&lt;/span>&lt;span style="color:#75715e">// không còn chính xác nữa
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>var&lt;/code> đặc biệt hơn với &lt;code>let&lt;/code> ở chỗ nó không tuân theo quy tắc chung. Chúng ta có thể kết luận rằng, khi khai báo &lt;strong>identifier&lt;/strong> với từ khoá &lt;code>var&lt;/code> sẽ có scope là global không? Tất nhiên là không!&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialVariable&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">initialVariable&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// ReferenceError: z is not defined
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Vậy nên ta không thể kết luận rằng &lt;strong>khai báo identifier với từ khoá &lt;code>var&lt;/code> sẽ có scope là global&lt;/strong>. Vậy thì lí do tại sao ví dụ ở trên lại bị sai nhỉ? Câu trả lời là đối với &lt;strong>scope&lt;/strong> của hàm thì có một chút khác biệt, có tên là &lt;strong>lexical&lt;/strong>. Khi khai báo &lt;strong>identifier&lt;/strong> bằng &lt;code>var&lt;/code>, thay vì &lt;strong>bind&lt;/strong> vào scope, thì &lt;strong>identifier&lt;/strong> được &lt;strong>bind&lt;/strong> vào &lt;strong>lexical&lt;/strong>. Ngoại trừ điều đó ra thì &lt;code>var&lt;/code> còn có khả năng &lt;strong>redeclarion&lt;/strong> (tái khai báo) mà không gặp lỗi. (làm với &lt;code>let&lt;/code> thì sẽ gặp lỗi &lt;code>SyntaxError: Identifier _ has already been declared&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;this is z at first&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">initialVariable&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z but 4th&amp;#39;&lt;/span> &lt;span style="color:#75715e">// redeclaration
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">initialVariable&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// this is z at first
&lt;/span>&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// this is z but 4th
&lt;/span>&lt;span style="color:#75715e">// this is z at first
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Xét thêm trường hợp này&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#a6e22e">fs&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span> () {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
})
}
&lt;span style="color:#a6e22e">fs&lt;/span>[&lt;span style="color:#ae81ff">3&lt;/span>]()
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// 5
&lt;/span>&lt;span style="color:#75715e">// i được khai báo ở lexical f, khi thực hiện vòng lặp với post operator là i++ thì
&lt;/span>&lt;span style="color:#75715e">// đang thay đổi giá trị của biến i ở lexical f.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ngoại trừ việc &lt;strong>bind&lt;/strong> khác một chút &lt;code>var&lt;/code> vẫn tuân theo quy tắc của &lt;strong>scope chain&lt;/strong>. Có nhiều bạn tưởng rằng &lt;code>var&lt;/code> sẽ tạo một property ở global object (cụ thể window ) - chưa hoàn toàn đúng, chỉ khi nào bạn khai báo bằng &lt;code>var&lt;/code> ở global scope thì mới tạo property, còn lại thì không.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;111&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(window.&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#a6e22e">f&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="const">&lt;code>const&lt;/code>&lt;/h1>
&lt;p>Điều khiến &lt;strong>identifier&lt;/strong> đặc biệt là không cho phép &lt;strong>direct assignment&lt;/strong>. Assignment là một toán tử cho phép cập nhật &lt;strong>giá trị&lt;/strong> đã được lưu trữ của &lt;strong>identifier&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;??&amp;#39;&lt;/span>
&lt;span style="color:#75715e">// TypeError: Assignment to constant variable.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tuy nhiên ,việc thay đổi nội tại bên trong, hoặc thay đổi thông qua trung gian vẫn có thể.(Đối với references data type)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#a6e22e">z&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// []
&lt;/span>&lt;span style="color:#75715e">// (4) [1, 2, 3, 4]
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {}
&lt;span style="color:#a6e22e">z&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;z&amp;#39;&lt;/span>
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#75715e">// {name: &amp;#34;z&amp;#34;}
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="hoisting--tempotary-dead-zone">Hoisting &amp;amp; Tempotary Dead Zone&lt;/h1>
&lt;ul>
&lt;li>Một &lt;strong>identifier&lt;/strong> được khỏi tạo thông qua 1 hoặc 2 giai đoạn : &lt;strong>declaration&lt;/strong> (&lt;strong>defination&lt;/strong>) và &lt;strong>initialization&lt;/strong>. Giai đoạn 2 có thể có hoặc không. &lt;strong>declaration&lt;/strong> mang ý nghĩa cấp vùng nhớ dùng để lưu giá trị và &lt;strong>bind identifier&lt;/strong> với giá trị có sẵn ở vùng nhớ(C++), &lt;strong>initialization&lt;/strong> mang ý nghĩa khởi tạo cho giá trị ban đầu là bao nhiêu. Nếu không có &lt;strong>initialization&lt;/strong> thì giá trị mạc định là &lt;strong>undefined&lt;/strong>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>;
&lt;span style="color:#75715e">// declaration
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>;
&lt;span style="color:#75715e">// declaration + initialization
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hãy xem xét các ví dụ sau:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#75715e">// ReferenceError: Cannot access &amp;#39;z&amp;#39; before initialization
&lt;/span>&lt;span style="color:#75715e">// Chúng ta đã sử dụng biến z trước khi nó được khai báo, đây được gọi là tdz
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;span style="color:#75715e">// undefined
&lt;/span>&lt;span style="color:#75715e">// Nếu thay let bằng var thì ta lại nhận được giá trị. Đây là ví dụ cho việc hoisting
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tempotary Dead Zone là khái niệm dùng để nói về việc sử dụng một &lt;strong>identifier&lt;/strong> trước khi được tạo ra.Hoisting áp dụng đối với &lt;strong>identifier&lt;/strong> được khai báo bằng từ khoá &lt;code>var&lt;/code> và &lt;code>function&lt;/code>. Hoisting chỉ hiệu quả trong một &lt;strong>lexical&lt;/strong>. Hoisting nghĩa là Javascript sẽ đem tất cả các biến phù hợp ( khai báo bằng &lt;code>var&lt;/code> và &lt;code>function&lt;/code>), thực hiện việc &lt;strong>declaration&lt;/strong> trước, khi đến dòng thực sự khai báo, chỉ phải thực hiện assignment mà thôi.&lt;/p>
&lt;p>TDZ không phải ám chỉ thứ tự khai báo các biến và sử dụng, mà thường dùng để nói về thứ tự thực thi (Execution Order). Miễn là tại thời điểm thực thi các biến đã được khởi là là ổn. TDZ thường hay đề cập đối với &lt;code>let&lt;/code> hơn là &lt;code>var&lt;/code> (&lt;code>var&lt;/code> sẽ Javascript áp dụng hoisting nên chuyện chưa được khởi tạo không xảy ra - chỉ có vấn đề là giá trị là undefined mà thôi). Để khắc phục tình trạng một biến gặp trường hợp &lt;strong>tdz&lt;/strong> thì nên cân nhắc đem tất cả các biến lên khai báo ở đầu scope/lexical&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>);
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is x&amp;#39;&lt;/span>;
}
&lt;span style="color:#75715e">// undefined
&lt;/span>&lt;span style="color:#75715e">// ReferenceError: Cannot access &amp;#39;x&amp;#39; before initialization
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">// Đây là ví dụ về thực thi
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>){
&lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">z&lt;/span>)
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z&amp;#39;&lt;/span>
}
&lt;span style="color:#a6e22e">f&lt;/span>() &lt;span style="color:#75715e">//
&lt;/span>&lt;span style="color:#75715e">// this is z
&lt;/span>&lt;span style="color:#75715e">// this is z - khi khai hàm bằng function =&amp;gt; giống như var
&lt;/span>&lt;span style="color:#75715e">// bind thẳng lexical chứ không phải scope - arrow function
&lt;/span>&lt;span style="color:#75715e">// khắc phục được điểm này
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi bạn sử dụng các từ khoá để khởi tạo các &lt;strong>identifier&lt;/strong>, thì các &lt;strong>identifier&lt;/strong> được bind vào scope/lexical tuỳ thuộc vào nơi khai báo. Nhưng &lt;strong>nếu&lt;/strong> bạn không khai báo biến mà trực tiếp &lt;strong>assignment&lt;/strong> thì mặc định Javascript sẽ làm tự động tạo cho bạn 1 biến ở &lt;strong>global scope&lt;/strong> (Nếu chưa tồn tại ở &lt;strong>scope chain&lt;/strong> dẫn ra &lt;strong>global scope&lt;/strong>)&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is x&amp;#39;&lt;/span>;
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>() {
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">g&lt;/span>(){
&lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;this is z lexical of g&amp;#39;&lt;/span>
}
&lt;span style="color:#a6e22e">g&lt;/span>()
}
&lt;span style="color:#a6e22e">f&lt;/span>();
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">globalThis&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>, &lt;span style="color:#a6e22e">z&lt;/span>);
&lt;span style="color:#75715e">// this is x this is z lexical of g
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h1 id="references--more-resources">References &amp;amp; more resources&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="ps">P/S:&lt;/h3>
&lt;p>Các đoạn code ở trên được mình chạy ở trên engine V8 của Chrome thông qua trình duyệt Brave. Có thể tuỳ thuộc vào các engine có một cách thực thi Javascript khác nhau nên có gì sai sót xin email cho mình để mình cập nhật. Xin cảm ơn!&lt;/p></description></item><item><title>Event Bubbling &amp; Capturing</title><link>https://sonlhcsuit.github.io/p/event-bubbles/</link><pubDate>Wed, 31 Mar 2021 11:14:24 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/event-bubbles/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/cover.png" alt="Featured image of post Event Bubbling &amp; Capturing" />&lt;p>Khi xử lý với Event thông qua DOM ở trong Javascript, cần phải hiểu một chút kỹ càng về cách các event hoạt động. Mỗi khi một event được &lt;strong>trigger&lt;/strong>, bắt đầu thực thi &lt;strong>listener&lt;/strong> thì cùng lúc cũng có nhiều &lt;strong>listener&lt;/strong> được kích hoạt cùng lúc. Có các cơ chế để trình duyệt thực hiện những &lt;strong>listener&lt;/strong> theo một thứ tự xác định. Các cơ chế cơ bản đó là bubble &amp;amp; capturing.&lt;/p>
&lt;p>Xem xét các ví dụ sau đây về độ sâu (depth) của cây DOM thông qua đoạn HTML&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-1&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-2&amp;#34;&lt;/span>&amp;gt;
&amp;lt;&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;box box-3&amp;#34;&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&amp;lt;/&lt;span style="color:#f92672">div&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-css" data-lang="css">&lt;span style="color:#f92672">*&lt;/span>{
&lt;span style="color:#66d9ef">margin&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">padding&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">box-sizing&lt;/span>: &lt;span style="color:#66d9ef">border-box&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span> {
&lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">block&lt;/span>;
&lt;span style="color:#66d9ef">margin&lt;/span>:&lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-1&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">red&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-2&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">30&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">30&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">black&lt;/span>;
}
.&lt;span style="color:#a6e22e">box&lt;/span>.&lt;span style="color:#a6e22e">box-3&lt;/span>{
&lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;span style="color:#66d9ef">border&lt;/span>: &lt;span style="color:#66d9ef">solid&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span> &lt;span style="color:#66d9ef">blue&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Khi hiển thị trên trình duyệt thì kết quả sẽ gồm 3 hình vuông lớn nhỏ theo kích thước và thứ tự sau:
&lt;figure style="flex-grow: 153; flex-basis: 367px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-1.png" data-size="1338x874">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-1.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-1_hu36b15a2e5c4bbafff2e4a73ac93e0b68_42228_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-1_hu36b15a2e5c4bbafff2e4a73ac93e0b68_42228_1024x0_resize_box_2.png 1024w"
width="1338"
height="874"
loading="lazy"
alt="Hiển thị đoạn của code ở phía trên">
&lt;/a>
&lt;figcaption>Hiển thị đoạn của code ở phía trên&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Box 3 - nằm trong Box 2 - nằm trong Box 1. Sử dụng một chút logic thì ta cũng có thể nhận thấy rằng khi người dùng click vào Box 3 thì cũng là người dùng click vào Box 2 và Box 1 (bởi vì Box 2 và Box 1 có kích thước lớn hơn và Box 3 nằm ở bên trong)&lt;/p>
&lt;p>Nếu chúng ta thêm các &lt;strong>listener&lt;/strong> vào event click, thì khi event được trigger ở Box 3 thì các &lt;strong>listener&lt;/strong> ở Box 2, Box 1 cũng được trigger theo. Và kết quả là cả 3 &lt;strong>listener&lt;/strong> đều được thực thi. Điều này đúng với logic căn bản, tuy nhiên nếu các &lt;strong>listener&lt;/strong> này xung đột lẫn nhau (ví dụ ẩn/hiện các component thì không hợp lý chút nào ). Cần nắm rõ cơ chế lan truyền - propagation - các event.&lt;/p>
&lt;p>Có 2 cơ chế lan truyền chính của các trình duyệt hiện tại là bubble &amp;amp; capture. Nhiều trình duyệt đã chuyển sang cơ chế mặc định là bubbles - từ &amp;ldquo;dưới lên &amp;ldquo;trên&amp;rdquo;. Còn cơ chế capture sẽ ngược lại, từ &amp;ldquo;trên&amp;rdquo; xuống &amp;ldquo;dưới&amp;rdquo;.&lt;/p>
&lt;p>Đối với cơ chế capture: trình duyệt sẽ bắt đầu từ gốc của cây DOM, tìm dần xuống tới element được kích hoạt (Box 3). Để tới được Box 3 thì phải trải qua các Node sau : html -&amp;gt; body -&amp;gt; box 1 -&amp;gt; box 2 -&amp;gt; box 3. Như vậy theo cách duyệt cây này thì các &lt;strong>listener&lt;/strong> sẽ được trigger theo thứ tự trên (nếu đã được định nghĩa). Còn cơ chế bubble sẽ thực hiện ngược lại, từ node lá duyệt ngược lên gốc: box 3 -&amp;gt; box 2 -&amp;gt; box 1 -&amp;gt; body -&amp;gt; html. Và các &lt;strong>listener&lt;/strong> sẽ được kích hoạt với thứ tự trên.&lt;/p>
&lt;p>Mặc định các trình duyệt hiện đại đều sử dụng cơ chế bubble. Tuy nhiên ta có thể chỉ định sử dụng cơ chết capture bằng cách sau.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> (){
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
})
})
&lt;span style="color:#75715e">// bubbles
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 221; flex-basis: 531px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-2.png" data-size="474x214">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-2.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-2_hu33a54f6207db267ccf397f69cccdda5b_8851_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-2_hu33a54f6207db267ccf397f69cccdda5b_8851_1024x0_resize_box_2.png 1024w"
width="474"
height="214"
loading="lazy"
alt="Cơ chế bubble">
&lt;/a>
&lt;figcaption>Cơ chế bubble&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
}, { &lt;span style="color:#a6e22e">capture&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span> })
})
&lt;span style="color:#75715e">// capture
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 213; flex-basis: 511px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-3.png" data-size="550x258">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-3.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-3_hua5307662f227eb14e7aaa5c68edc7b51_10014_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-3_hua5307662f227eb14e7aaa5c68edc7b51_10014_1024x0_resize_box_2.png 1024w"
width="550"
height="258"
loading="lazy"
alt="Cơ chế capture">
&lt;/a>
&lt;figcaption>Cơ chế capture&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Tuy nhiên đôi khi chúng ta cần ngăn chặn sự lan truyền (tức là chỉ kích hoạt những listener phía trước để đảm bảo đúng dữ kiện ) bằng cách sử dụng phương thức &lt;strong>Event.stopPropagation()&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">document.&lt;span style="color:#a6e22e">querySelectorAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;.box&amp;#39;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#a6e22e">element&lt;/span> =&amp;gt; {
&lt;span style="color:#a6e22e">element&lt;/span>.&lt;span style="color:#a6e22e">addEventListener&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;click&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">event&lt;/span>) {
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classList&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>)
&lt;span style="color:#a6e22e">event&lt;/span>.&lt;span style="color:#a6e22e">stopPropagation&lt;/span>()
},
{
&lt;span style="color:#75715e">// capture:true
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
)
})
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;figure style="flex-grow: 173; flex-basis: 416px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-4.png" data-size="430x248">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-4.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-4_hu4046789cdb57c522a976de3cc6f690b0_6032_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-4_hu4046789cdb57c522a976de3cc6f690b0_6032_1024x0_resize_box_2.png 1024w"
width="430"
height="248"
loading="lazy"
alt="Cơ chế bubble với stopPropagation">
&lt;/a>
&lt;figcaption>Cơ chế bubble với stopPropagation&lt;/figcaption>
&lt;/figure>
&lt;figure style="flex-grow: 178; flex-basis: 428px">
&lt;a href="https://sonlhcsuit.github.io/p/event-bubbles/pic-5.png" data-size="414x232">&lt;img src="https://sonlhcsuit.github.io/p/event-bubbles/pic-5.png"
srcset="https://sonlhcsuit.github.io/p/event-bubbles/pic-5_hue6344ce93fbc2e689f10c298a8dd30f4_5414_480x0_resize_box_2.png 480w, https://sonlhcsuit.github.io/p/event-bubbles/pic-5_hue6344ce93fbc2e689f10c298a8dd30f4_5414_1024x0_resize_box_2.png 1024w"
width="414"
height="232"
loading="lazy"
alt="Cơ chế capture với stopPropagation">
&lt;/a>
&lt;figcaption>Cơ chế capture với stopPropagation&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>Wednesday 31/03/2021&lt;/p></description></item><item><title>Valentine Trang</title><link>https://sonlhcsuit.github.io/p/valentine-trang/</link><pubDate>Mon, 15 Mar 2021 01:17:31 +0700</pubDate><guid>https://sonlhcsuit.github.io/p/valentine-trang/</guid><description>&lt;img src="https://sonlhcsuit.github.io/p/valentine-trang/cover.png" alt="Featured image of post Valentine Trang" />&lt;p>Hôm nay cũng như bao hôm khác, sẽ là một ngày chủ nhật thật đẹp với bầu trời xanh của thành phố quen thuộc.&lt;/p>
&lt;p>Mới vừa bước ra công ty sau một ngày chủ nhật mệt mỏi, lái trên đường về dọc kênh Nhiêu Lộc - Thị Nghè. Đang trên đường mà cứ thả hồn vào trời mây, việc lái xe thì nhường lại cho tay chân với phản xạ cơ bản.&lt;/p>
&lt;p>Không hiểu vì lí do gì mà cảm xúc trống rỗng, buồn,&amp;hellip; lấp đầy tâm trí. Không biết buồn vì điều chi, chỉ cảm thấy thiếu 1 thứ gì đó rất quan trọng.&lt;/p>
&lt;p>Càng lớn, cảm xúc tích cực càng ít đi, thay vào đó là những khoảng lặng.&lt;/p>
&lt;p>Sực nhớ ra hôm nay là valentine trắng, dường như chính cảm xúc mình lại chết một ít.&lt;/p>
&lt;p>Sunday 14/03/21&lt;/p></description></item></channel></rss>